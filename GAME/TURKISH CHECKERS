# Импорт необходимых модулей
from tkinter import *
import os
from tkinter import messagebox
from PIL import Image
from PIL import ImageTk

# Класс, представляющий шашечную доску
class CheckersBoard:

    def reset_board(self):
        # Сброс игровой доски и отображение начальной позиции фигур
        self.board = [
            [0, 0, 0, 0, 0, 0, 0, 0],
            [2, 2, 2, 2, 2, 2, 2, 2], # Второй игрок
            [2, 2, 2, 2, 2, 2, 2, 2], # Черные фигуры
            [0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0],
            [1, 1, 1, 1, 1, 1, 1, 1], # Первый игрок
            [1, 1, 1, 1, 1, 1, 1, 1], # Белые фигуры
            [0, 0, 0, 0, 0, 0, 0, 0]
        ]
        self.canvas.delete("all") # Удаление всех элементов на холсте
        self.draw_board(self.current_player) # Отрисовка начального состояния доски

    def check_col(self, start, end, col):
        # Проверка на возможность хода по столбцу
        count = 0  # Счетчик шашек в столбце
        index = 0  # Индекс возможного хода
        correct_ind = end
        if start > end:
            start, end = end - 1, start - 1
        else:
            correct_ind -= 2
        for i in range(start + 1, end + 1):
            if self.board[i][col] != 0:  # Если в клетке есть шашка
                if self.board[i][col] in self.current_player:  # Если шашка принадлежит текущему игроку
                    count += 1
                count += 1
                index = i + 1
        if count == 0:
            return [True, False]
        elif count == 1 and correct_ind + 1 == index - 1:
            return [True, index]
        else:
            return [False, False]

    def check_row(self, start, end, row):
        # Проверка на возможность хода по строке
        count = 0
        index = 0
        correct_ind = end - 1
        if start > end:
            correct_ind += 2
            start, end = end, start
        for i in range(start + 1, end):
            if self.board[row][i] != 0:  # Если в клетке есть шашка
                if self.board[row][i] in self.current_player:
                    count += 1  # Увеличиваем счетчик шашек
                index = i + 1  # Устанавливаем индекс возможного хода
                count += 1  # Увеличиваем счетчик шашек
        if count == 0:
            return [True, False]  # Возможный ход без взятия
        elif count == 1 and correct_ind == index - 1:
            return [True, index]  # Возможный ход с взятием
        else:
            return [False, False]  # Ход невозможен

    def attack(self, take, row, col):
        # Если нет взятий
        if not take:
            # Если текущий игрок - 1 или 3
            if self.current_player == [1, 3]:
                # Перебираем клетки доски
                for i in range(8):
                    for j in range(8):
                        try:
                            # Если фишка на доске является дамкой или обычной фишкой игрока
                            if self.board[i][j] in [2, 4]:
                                # Проверяем возможные ходы вверх и вниз
                                if self.board[i - 1][j] == 0:
                                    for k in range(i + 1, 8):
                                        if self.board[k][j] == 3:
                                            self.need_attack = True
                                            break
                                        elif self.board[k][j] in [1, 2, 3, 4]:
                                            break
                                if self.board[i + 1][j] == 0:
                                    for k in range(i - 1, -1, -1):
                                        if self.board[k][j] == 3:
                                            self.need_attack = True
                                            break
                                        elif self.board[k][j] == 1 and abs(i - k) == 1:
                                            self.need_attack = True
                                            break
                                        elif self.board[k][j] in [1, 2, 3, 4]:
                                            break
                        except IndexError:
                            pass
                # Перебираем клетки доски
                for i in range(8):
                    for j in range(8):
                        try:
                            # Если фишка на доске является дамкой или обычной фишкой игрока
                            if self.board[i][j] in [2, 4]:
                                # Проверяем возможные ходы влево и вправо
                                if self.board[i][j - 1] == 0:
                                    for k in range(j + 1, 8):
                                        if self.board[i][k] == 3:
                                            self.need_attack = True
                                            break
                                        elif self.board[i][k] == 1 and abs(j - k) == 1:
                                            self.need_attack = True
                                            break
                                        elif self.board[i][k] in [1, 2, 3, 4]:
                                            break
                                if self.board[i][j + 1] == 0:
                                    for k in range(j - 1, -1, -1):
                                        if self.board[i][k] == 3:
                                            self.need_attack = True
                                            break
                                        elif self.board[i][k] == 1 and abs(j - k) == 1:
                                            self.need_attack = True
                                            break
                                        elif self.board[i][k] in [1, 2, 3, 4]:
                                            break
                        except IndexError:
                            pass
            # Если текущий игрок - 2 или 4
            if self.current_player == [2, 4]:
                # Перебираем клетки доски
                for i in range(8):
                    for j in range(8):
                        try:
                            # Если фишка на доске является дамкой или обычной фишкой игрока
                            if self.board[i][j] in [1, 3]:
                                # Проверяем возможные ходы вверх и вниз
                                if self.board[i - 1][j] == 0:
                                    for k in range(i + 1, 8):
                                        if self.board[k][j] == 4:
                                            self.need_attack = True
                                            break
                                        elif self.board[k][j] == 2 and abs(i - k) == 1:
                                            self.need_attack = True
                                            break
                                        elif self.board[k][j] in [1, 3]:
                                            break
                                if self.board[i + 1][j] == 0:
                                    for k in range(i - 1, -1, -1):
                                        if self.board[k][j] == 4:
                                            self.need_attack = True
                                            break
                                        elif self.board[k][j] in [1, 2, 3, 4]:
                                            break
                        except IndexError:
                            pass
                # Перебираем клетки доски
                for i in range(8):
                    for j in range(8):
                        try:
                            # Если фишка на доске является дамкой или обычной фишкой игрока
                            if self.board[i][j] in [1, 3]:
                                # Проверяем возможные ходы влево и вправо
                                if self.board[i][j - 1] == 0:
                                    for k in range(j + 1, 8):
                                        if self.board[i][k] == 4:
                                            self.need_attack = True
                                            break
                                        elif self.board[i][k] == 2 and abs(j - k) == 1:
                                            self.need_attack = True
                                            break
                                        elif self.board[i][k] in [1, 3]:
                                            break
                                if self.board[i][j + 1] == 0:
                                    for k in range(j - 1, -1, -1):
                                        if self.board[i][k] == 4:
                                            self.need_attack = True
                                            break
                                        elif self.board[i][k] == 2 and abs(j - k) == 1:
                                            self.need_attack = True
                                            break
                                        elif self.board[i][k] in [1, 2, 3, 4]:
                                            break
                        except IndexError:
                            pass


    def check_win(self):
        # Проверка на завершение игры и определение победителя или ничьей
        count = 0
        count2 = 0
        for i in range(8):
            count += self.board[i].count(1)
            count += self.board[i].count(3)
            count2 += self.board[i].count(2)
            count2 += self.board[i].count(4)
        if count > 0 >= count2: # Проверяет, выиграл ли игрок 1 (черные), если количество его фишек больше нуля, а у игрока 2 (белых) равно нулю
            messagebox.showinfo("Уведомление", "Победа черных!")
            self.reset_board()
        elif count2 > 0 >= count: # Проверяет, выиграл ли игрок 2 (белые), если количество его фишек больше нуля, а у игрока 1 (черных) равно нулю
            messagebox.showinfo("Уведомление", "Победа белых!")
            self.reset_board()
        elif count == count2 == 1: # Проверяет, наступила ли ничья, если количество фишек у обоих игроков равно 1
            messagebox.showinfo("Уведомление", "Игра закончилась ничьей!")
            self.reset_board()
        else:
            count = 0 # Сбрасывает переменную count для подсчета возможных ходов у игрока 1 (черных)
            count2 = 0 # Сбрасывает переменную count2 для подсчета возможных ходов у игрока 2 (белых)
            for i in range(8):
                for j in range(8):
                    if self.board[i][j] in [1, 3]:
                        try:
                            if self.board[i + 1][j] == 0 or (
                                    self.board[i + 1][j] in [2, 4] and self.board[i + 2][j] == 0):
                                count += 1
                            elif self.board[i][j + 1] == 0 or (
                                    self.board[i][j + 1] in [2, 4] and self.board[i][j + 2] == 0):
                                count += 1
                            elif self.board[i][j - 1] == 0 or (
                                    self.board[i][j - 1] in [2, 4] and self.board[i][j - 2] == 0):
                                count += 1
                        except IndexError:
                            pass
                    elif self.board[i][j] in [2, 4]:
                        try:
                            if self.board[i - 1][j] == 0 or (
                                    self.board[i - 1][j] in [1, 3] and self.board[i - 2][j] == 0):
                                count2 += 1
                            elif self.board[i][j + 1] == 0 or (
                                    self.board[i][j + 1] in [1, 3] and self.board[i][j + 2] == 0):
                                count2 += 1
                            elif self.board[i][j - 1] == 0 or (
                                    self.board[i][j - 1] in [1, 3] and self.board[i][j - 2] == 0):
                                count2 += 1
                        except IndexError:
                            pass
            print(count, count2)
            if count == 0:
                messagebox.showinfo("Уведомление", "Победа белых!")
                self.reset_board()
            if count2 == 0:
                messagebox.showinfo("Уведомление", "Победа черных!")
                self.reset_board()


    def switch_player(self):
        # Переключение текущего игрока между [1, 3] и [2, 4]
        if self.current_player == [1, 3]:
            self.current_player = [2, 4]
        else:
            self.current_player = [1, 3]
    def v_moves(self, src_row, src_col, dest_row, dest_col):
        # Если исходная клетка содержит обычную фишку и клетка назначения пуста
        if self.board[src_row][src_col] == 1 and self.board[dest_row][dest_col] == 0:
            # Проверяем возможные ходы для обычной фишки
            if (dest_row - src_row == -1 and abs(dest_col - src_col) == 0) or \
                    (dest_row - src_row == 0 and abs(dest_col - src_col) == 1):
                # Если нет необходимости в атаке
                if not self.need_attack:
                    return [True, False]
            elif (dest_row - src_row == -2 and abs(dest_col - src_col) == 0 and
                  self.board[dest_row + 1][dest_col] in [2, 4]):
                # Если возможно взятие по вертикали
                self.board[dest_row + 1][dest_col] = 0
                if self.need_attack:
                    self.need_attack = False
                try:
                    if self.board[dest_row - 1][dest_col] in [2, 4] and self.board[dest_row - 2][dest_col] == 0:
                        return [True, True]
                    elif self.board[dest_row][dest_col - 1] in [2, 4] and self.board[dest_row][dest_col - 2] == 0:
                        return [True, True]
                    elif self.board[dest_row][dest_col + 1] in [2, 4] and self.board[dest_row][dest_col + 2] == 0:
                        return [True, True]
                    else:
                        return [True, False]
                except IndexError:
                    return [True, False]
            elif dest_col - src_col == 2 and dest_row == src_row and self.board[dest_row][
                dest_col - 1] in [2, 4]:
                # Если возможно взятие по горизонтали
                self.board[dest_row][dest_col - 1] = 0
                if self.need_attack:
                    self.need_attack = False
                try:
                    if self.board[dest_row + 1][dest_col] in [2, 4] and self.board[dest_row + 2][dest_col] == 0:
                        return [True, True]
                    elif self.board[dest_row][dest_col + 1] in [2, 4] and self.board[dest_row][dest_col + 2] == 0:
                        return [True, True]
                    else:
                        return [True, False]
                except IndexError:
                    return [True, False]
            elif dest_col - src_col == -2 and dest_row == src_row and self.board[dest_row][
                dest_col + 1] in [2, 4]:
                # Если возможно взятие по горизонтали
                self.board[dest_row][dest_col + 1] = 0
                if self.need_attack:
                    self.need_attack = False
                try:
                    if self.board[dest_row + 1][dest_col] in [2, 4] and self.board[dest_row + 2][dest_col] == 0:
                        return [True, True]
                    elif self.board[dest_row][dest_col - 1] in [2, 4] and self.board[dest_row][dest_col - 2] == 0:
                        return [True, True]
                    else:
                        return [True, False]
                except IndexError:
                    return [True, False]
        # Если исходная клетка содержит дамку и клетка назначения пуста
        elif self.board[src_row][src_col] == 3 and self.board[dest_row][dest_col] == 0:
            # Проверяем возможные ходы для дамки
            if (abs(dest_row - src_row) >= 1 and abs(dest_col - src_col) == 0) or \
                    (abs(dest_row - src_row) == 0 and abs(dest_col - src_col) >= 1):
                if src_col == dest_col:
                    # Проверяем возможные ходы по вертикали
                    correct, attack = self.check_col(src_row, dest_row, src_col)
                    if correct and attack == 0 and not self.need_attack:
                        return [True, False]
                    elif correct and attack >= 1:
                        # Выполняем взятие
                        self.board[attack - 1][src_col] = 0
                        # Проверяем возможные ходы после взятия
                        if dest_row - (attack - 1) > 0:
                            try:
                                for i in range(dest_row + 1, 8):
                                    if self.board[i][dest_col] in [2, 4] and self.board[i + 1][dest_col] == 0:
                                        return [True, True]
                                    elif self.board[i][dest_col] in [1, 2, 3, 4]:
                                        break
                            except IndexError:
                                pass
                            try:
                                for i in range(dest_col + 1, 8):
                                    if self.board[dest_row][i] in [2, 4] and self.board[dest_row][i + 1] == 0:
                                        return [True, True]
                                    elif self.board[dest_row][i] in [1, 2, 3, 4]:
                                        break
                            except IndexError:
                                pass
                            try:
                                for i in range(dest_col - 1, 0, -1):
                                    if self.board[dest_row][i] in [2, 4] and self.board[dest_row][i - 1] == 0:
                                        return [True, True]
                                    elif self.board[dest_row][i] in [1, 2, 3, 4]:
                                        break
                            except IndexError:
                                pass
                        elif dest_row - (attack - 1) < 0:
                            try:
                                for i in range(dest_row - 1, 0, -1):
                                    if self.board[i][dest_col] in [2, 4] and self.board[i - 1][dest_col] == 0:
                                        return [True, True]
                                    elif self.board[i][dest_col] in [1, 2, 3, 4]:
                                        break
                            except IndexError:
                                pass
                            try:
                                for i in range(dest_col + 1, 8):
                                    if self.board[dest_row][i] in [2, 4] and self.board[dest_row][i + 1] == 0:
                                        return [True, True]
                                    elif self.board[dest_row][i] in [1, 2, 3, 4]:
                                        break
                            except IndexError:
                                pass
                            try:
                                for i in range(dest_col - 1, 0, -1):
                                    if self.board[dest_row][i] in [2, 4] and self.board[dest_row][i - 1] == 0:
                                        return [True, True]
                                    elif self.board[dest_row][i] in [1, 2, 3, 4]:
                                        break
                            except IndexError:
                                pass
                        return [True, False]
                    else:
                        if not take:
                            return [False, False]
                elif src_row == dest_row:
                    # Проверяем возможные ходы по горизонтали
                    correct, attack = self.check_row(src_col, dest_col, src_row)
                    if correct and attack == 0 and not self.need_attack:
                        return [True, False]
                    elif correct and attack >= 1:
                        # Выполняем взятие
                        self.board[src_row][attack - 1] = 0
                        # Проверяем возможные ходы после взятия
                        if dest_col - (attack - 1) > 0:
                            try:
                                for i in range(dest_col + 1, 8):
                                    if self.board[dest_row][i] in [2, 4] and self.board[dest_row][i + 1] == 0:
                                        return [True, True]
                                    elif self.board[dest_row][i] in [1, 2, 3, 4]:
                                        break
                            except IndexError:
                                pass
                            try:
                                for i in range(dest_row + 1, 8):
                                    if self.board[i][dest_col] in [2, 4] and self.board[i + 1][dest_col] == 0:
                                        return [True, True]
                                    elif self.board[i][dest_col] in [1, 2, 3, 4]:
                                        break
                            except IndexError:
                                pass
                            try:
                                for i in range(dest_row - 1, 0, -1):
                                    if self.board[i][dest_col] in [2, 4] and self.board[i - 1][dest_col] == 0:
                                        return [True, True]
                                    elif self.board[i][dest_col] in [1, 2, 3, 4]:
                                        break
                            except IndexError:
                                pass
                        elif dest_col - (attack - 1) < 0:
                            try:
                                for i in range(dest_col - 1, 0, -1):
                                    if self.board[dest_row][i] in [2, 4] and self.board[dest_row][i - 1] == 0:
                                        return [True, True]
                                    elif self.board[dest_row][i] in [1, 2, 3, 4]:
                                        break
                            except IndexError:
                                pass
                            try:
                                for i in range(dest_row + 1, 8):
                                    if self.board[i][dest_col] in [2, 4] and self.board[i + 1][dest_col] == 0:
                                        return [True, True]
                                    elif self.board[i][dest_col] in [1, 2, 3, 4]:
                                        break
                            except IndexError:
                                pass
                            try:
                                for i in range(dest_row - 1, 0, -1):
                                    if self.board[i][dest_col] in [2, 4] and self.board[i - 1][dest_col] == 0:
                                        return [True, True]
                                    elif self.board[i][dest_col] in [1, 2, 3, 4]:
                                        break
                            except IndexError:
                                pass
                        return [True, False]
                    else:
                        if not take:
                            return [False, False]
        # Если исходная клетка содержит фишку-дамку и клетка назначения пуста
        elif self.board[src_row][src_col] == 2 and self.board[dest_row][dest_col] == 0:
            # Проверяем возможные ходы для фишки-дамки
            if (dest_row - src_row == 1 and abs(dest_col - src_col) == 0) or \
                    (dest_row - src_row == 0 and abs(dest_col - src_col) == 1):
                # Если нет необходимости в атаке
                if not self.need_attack:
                    return [True, False]
            elif (dest_row - src_row == 2 and abs(dest_col - src_col) == 0 and
                  self.board[dest_row - 1][dest_col] in [1, 3]):
                # Если возможно взятие по вертикали
                self.board[dest_row - 1][dest_col] = 0
                if self.need_attack:
                    self.need_attack = False
                try:
                    if self.board[dest_row + 1][dest_col] in [1, 3] and self.board[dest_row + 2][dest_col] == 0:
                        return [True, True]
                    elif self.board[dest_row][dest_col - 1] in [1, 3] and self.board[dest_row][dest_col - 2] == 0:
                        return [True, True]
                    elif self.board[dest_row][dest_col + 1] in [1, 3] and self.board[dest_row][dest_col + 2] == 0:
                        return [True, True]
                    else:
                        return [True, False]
                except IndexError:
                    return [True, False]
            elif dest_col - src_col == 2 and dest_row == src_row and self.board[dest_row][
                dest_col - 1] in [1, 3]:
                # Если возможно взятие по горизонтали
                self.board[dest_row][dest_col - 1] = 0
                if self.need_attack:
                    self.need_attack = False
                try:
                    if self.board[dest_row - 1][dest_col] in [1, 3] and self.board[dest_row - 2][dest_col] == 0:
                        return [True, True]
                    elif self.board[dest_row][dest_col + 1] in [1, 3] and self.board[dest_row][dest_col + 2] == 0:
                        return [True, True]
                    else:
                        return [True, False]
                except IndexError:
                    return [True, False]
            elif dest_col - src_col == -2 and dest_row == src_row and self.board[dest_row][
                dest_col + 1] in [1, 3]:
                # Если возможно взятие по горизонтали
                self.board[dest_row][dest_col + 1] = 0
                if self.need_attack:
                    self.need_attack = False
                try:
                    if self.board[dest_row - 1][dest_col] in [1, 3] and self.board[dest_row - 2][dest_col] == 0:
                        return [True, True]
                    elif self.board[dest_row][dest_col - 1] in [1, 3] and self.board[dest_row][dest_col - 2] == 0:
                        return [True, True]
                    else:
                        return [True, False]
                except IndexError:
                    return [True, False]
        elif self.board[src_row][src_col] == 4 and self.board[dest_row][dest_col] == 0: # Если исходная клетка содержит дамку и клетка назначения пуста
            if (abs(dest_row - src_row) >= 1 and abs(dest_col - src_col) == 0) or \
                    (abs(dest_row - src_row == 0) and abs(dest_col - src_col) >= 1):
                if src_col == dest_col:
                    correct, attack = self.check_col(src_row, dest_row, src_col)
                    if correct and attack == 0 and not self.need_attack:
                        return [True, False]
                    elif correct and attack >= 1:
                        self.board[attack - 1][src_col] = 0
                        if dest_row - (attack - 1) > 0:
                            try:
                                for i in range(dest_row + 1, 8):
                                    if self.board[i][dest_col] in [1, 3] and self.board[i + 1][dest_col] == 0:
                                        return [True, True]
                                    elif self.board[i][dest_col] in [1, 2, 3, 4]:
                                        break
                            except IndexError:
                                pass
                            try:
                                for i in range(dest_col + 1, 8):
                                    if self.board[dest_row][i] in [1, 3] and self.board[dest_row][i + 1] == 0:
                                        return [True, True]
                                    elif self.board[dest_row][i] in [1, 2, 3, 4]:
                                        break
                            except IndexError:
                                pass
                            try:
                                for i in range(dest_col - 1, 0, -1):
                                    if self.board[dest_row][i] in [1, 3] and self.board[dest_row][i - 1] == 0:
                                        return [True, True]
                                    elif self.board[dest_row][i] in [1, 2, 3, 4]:
                                        break
                            except IndexError:
                                pass
                        elif dest_row - (attack - 1) < 0:
                            try:
                                for i in range(dest_row - 1, 0, -1):
                                    if self.board[i][dest_col] in [1, 3] and self.board[i - 1][dest_col] == 0:
                                        return [True, True]
                                    elif self.board[i][dest_col] in [1, 2, 3, 4]:
                                        break
                            except IndexError:
                                pass
                            try:
                                for i in range(dest_col + 1, 8):
                                    if self.board[dest_row][i] in [1, 3] and self.board[dest_row][i + 1] == 0:
                                        return [True, True]
                                    elif self.board[dest_row][i] in [1, 2, 3, 4]:
                                        break
                            except IndexError:
                                pass
                            try:
                                for i in range(dest_col - 1, 0, -1):
                                    if self.board[dest_row][i] in [1, 3] and self.board[dest_row][i - 1] == 0:
                                        return [True, True]
                                    elif self.board[dest_row][i] in [1, 2, 3, 4]:
                                        break
                            except IndexError:
                                pass
                        return [True, False]
                    else:
                        if not take:
                            return [False, False]
                elif src_row == dest_row:
                    correct, attack = self.check_row(src_col, dest_col, src_row)
                    if correct and attack == 0 and not self.need_attack:
                        return [True, False]
                    elif correct and attack >= 1:
                        self.board[src_row][attack - 1] = 0
                        if dest_col - (attack - 1) > 0:
                            try:
                                for i in range(dest_col + 1, 8):
                                    if self.board[dest_row][i] in [1, 3] and self.board[dest_row][i + 1] == 0:
                                        return [True, True]
                                    elif self.board[dest_row][i] in [1, 2, 3, 4]:
                                        break
                            except IndexError:
                                pass
                            try:
                                for i in range(dest_row + 1, 8):
                                    if self.board[i][dest_col] in [1, 3] and self.board[i + 1][dest_col] == 0:
                                        return [True, True]
                                    elif self.board[i][dest_col] in [1, 2, 3, 4]:
                                        break
                            except IndexError:
                                pass
                            try:
                                for i in range(dest_row - 1, 0, -1):
                                    if self.board[i][dest_col] in [1, 3] and self.board[i - 1][dest_col] == 0:
                                        return [True, True]
                                    elif self.board[i][dest_col] in [1, 2, 3, 4]:
                                        break
                            except IndexError:
                                pass
                        elif dest_col - (attack - 1) < 0:
                            try:
                                for i in range(dest_col - 1, 0, -1):
                                    if self.board[dest_row][i] in [1, 3] and self.board[dest_row][i - 1] == 0:
                                        return [True, True]
                                    elif self.board[dest_row][i] in [1, 2, 3, 4]:
                                        break
                            except IndexError:
                                pass
                            try:
                                for i in range(dest_row + 1, 8):
                                    if self.board[i][dest_col] in [1, 3] and self.board[i + 1][dest_col] == 0:
                                        return [True, True]
                                    elif self.board[i][dest_col] in [1, 2, 3, 4]:
                                        break
                            except IndexError:
                                pass
                            try:
                                for i in range(dest_row - 1, 0, -1):
                                    if self.board[i][dest_col] in [1, 3] and self.board[i - 1][dest_col] == 0:
                                        return [True, True]
                                    elif self.board[i][dest_col] in [1, 2, 3, 4]:
                                        break
                            except IndexError:
                                pass
                        return [True, False]
                    else:
                        if not take:
                            return [False, False]
        return [False, False]

        # Инициализация главного окна
    def __init__(self, master):
        self.master = master
        self.master.title("Турецкие шашки-поддавки by Sergey Prokofev")
        self.master.resizable(False, False)
        self.center_window()
        self.canvas = Canvas(self.master, width=540, height=450, bg="azure3")
        self.canvas.pack(side=RIGHT)
        self.users = {}
        self.canvas.pack()
        self.users = {}
        # Загрузка изображений шашек и дамок
        global black_queen, white_queen, black_checker, white_checker
        black_checker = ImageTk.PhotoImage(
                (Image.open('black-regular1.png')).resize((50, 50), Image.Resampling.LANCZOS))
        black_queen = ImageTk.PhotoImage(
                (Image.open('black-queen1.png')).resize((50, 50), Image.Resampling.LANCZOS))
        white_checker = ImageTk.PhotoImage(
                (Image.open('white-regular1.png')).resize((50, 50), Image.Resampling.LANCZOS))
        white_queen = ImageTk.PhotoImage(
                (Image.open('white-queen1.png')).resize((50, 50), Image.Resampling.LANCZOS))
        # Инициализация переменных для игры
        global take, correct
        take = False
        correct = False
        self.board = [[0, 0, 0, 0, 0, 0, 0, 0],
                      [2, 2, 2, 2, 2, 2, 2, 2],
                      [2, 2, 2, 2, 2, 2, 2, 2],
                      [0, 0, 0, 0, 0, 0, 0, 0],
                      [0, 0, 0, 0, 0, 0, 0, 0],
                      [1, 1, 1, 1, 1, 1, 1, 1],
                      [1, 1, 1, 1, 1, 1, 1, 1],
                      [0, 0, 0, 0, 0, 0, 0, 0]]
        self.current_player = [1, 3]
        self.selected_piece = None
        self.selected_rectangle = None
        self.need_attack = False
        # Создание виджетов для авторизации
        self.label = Label(text="Вход в аккаунт", bg='azure3', font=("Arial", 15))
        self.label_login = Label(text="Имя", bg='azure3', font="Arial 14")
        self.label_password = Label(text="Пароль", bg='azure3', font="Arial 14")
        self.entry_login = Entry(width=30, justify="center")
        self.entry_password = Entry(width=30, justify="center")
        self.button_auth = Button(text="Авторизироваться", bg='azure3', font="Arial 14",
                                      command=lambda: self.authorization())
        self.button_reg = Button(text="Зарегистрироваться", bg='azure3', font="Arial 14",
                                     command=lambda: self.registrate())
        self.button_back = Button(text="Выход", command=lambda: self.authorization())
        # Размещение виджетов на экране
        self.label.place(x=150, y=10)
        self.label_login.place(x=80, y=85)
        self.entry_login.place(x=150, y=85)
        self.label_password.place(x=70, y=135)
        self.entry_password.place(x=150, y=135)
        self.button_auth.place(x=150, y=175, width=185)
        self.button_reg.place(x=150, y=220, width=185)

    # Метод для центрирования окна на экране
    def center_window(self):
        screen_width = self.master.winfo_screenwidth()
        screen_height = self.master.winfo_screenheight()
        window_width = 450
        window_height = 450

        x = int((screen_width / 2) - (window_width / 2))
        y = int((screen_height / 2) - (window_height / 2))

        self.master.geometry(f"{window_width}x{window_height}+{x}+{y}")

    # Метод для кодирования пароля
    def password_code(self, password):
        key = 2
        coded_password = ""
        for i in password:
            coded_password_temp = chr(ord(i) + key)
            coded_password += coded_password_temp
            key = -key + 1
        return coded_password

    # Метод для открытия файла с пользователями
    def open_file(self):
        try:
            text = open("users.txt", "r+")
            return text
        except FileNotFoundError:
            try:
                text = open("users.txt", "w")
                text.close()
                text = open("users.txt", "r+")
                return text
            except FileNotFoundError:
                text = open("users.txt", "r+")
                return text

    # Метод для авторизации пользователя
    def authorization(self):
        login = self.entry_login.get()
        password_raw = self.entry_password.get()
        password = self.password_code(password_raw)

        # Проверка наличия введенных данных
        if len(login) == 0 and len(password) == 0:
            messagebox.showwarning(title="Ошибка!", message="Введите имя и пароль")
            return
        elif len(login) == 0 and len(password) != 0:
            messagebox.showwarning(title="Ошибка!", message="Введите имя")
            return
        elif len(login) != 0 and len(password) == 0:
            messagebox.showwarning(title="Ошибка!", message="Введите пароль")
            return

        # Открытие файла с пользователями
        file = self.open_file()
        a = file.readline()[:-1].split(" ")

        # Заполнение словаря пользователей
        while True:
            if a != [""]:
                self.users[a[0]] = a[1]
                a = file.readline()[:-1].split(" ")
            else:
                break

        # Проверка правильности введенных данных
        flag_reg = False
        for i in self.users.items():
            login_check, password_check = i
            if login == login_check and password == password_check:
                flag_reg = True
                break

        # Обработка результата авторизации
        if flag_reg:
            for widget in self.master.winfo_children():
                widget.destroy()

            Label(self.master, text="Вы успешно авторизировались!", font="Arial 16 bold").place(x=55, y=60)
            button = Button(text="Играть", command=self.do_game, bg="azure3", font="Arial 19 bold")
            button.place(x=175, y=150)
        else:
            messagebox.showwarning(title="Ошибка", message="Такого пользователя не существует")

    # Метод для регистрации нового пользователя
    def registrate(self):
        login = self.entry_login.get()
        password_raw = self.entry_password.get()
        password = self.password_code(password_raw)

        # Проверка корректности введенных данных
        if len(login) == 0 or len(password) == 0:
            messagebox.showwarning(title="Ошибка", message="Введите имя и пароль")
            return

        # Получение данных о пользователях из файла
        lines = self.open_file()
        self.users = {}
        for line in lines:
            l, p = line.strip().split(" ")
            self.users[l] = p

        # Запись нового пользователя в файл
        if login not in self.users:
            with open("users.txt", "a") as file:
                file.write(f'{login} {password}\n')
            self.show_success_message()
        else:
            messagebox.showwarning(title="Ошибка!", message="Такой аккаунт уже есть!")

    # Метод для начала игры
    def do_game(self):
        self.master.title("шашки")
        self.canvas = Canvas(self.master, width=400, height=450, bg="#666666")
        self.canvas.pack()
        self.canvas.bind("<Button-1>", self.on_click)
        self.draw_board(self.current_player)

    # Метод для отрисовки игровой доски
    def draw_board(self, current_plr):
        # Отображение текущего игрока
        if current_plr == [1, 3]:
            self.canvas.create_text(200, 425, text="Ход белых", font=("Arial", 20), fill="#cccccc")
        else:
            self.canvas.create_text(200, 425, text="Ход чёрных", font=("Arial", 20), fill="#1a1a1a")

        # Отрисовка клеток доски
        for row in range(8):
            for col in range(8):
                x1, y1 = col * 50, row * 50
                x2, y2 = x1 + 50, y1 + 50
                color = "#8a6341" if (row + col) % 2 == 0 else "#8a6341"
                self.canvas.create_rectangle(x1, y1, x2, y2, fill=color)

                piece = self.board[row][col]
                # Отображение шашек на доске
                if piece == 1:
                    self.canvas.create_image(x1, y1, anchor='nw', image=white_checker)
                elif piece == 2:
                    self.canvas.create_image(x1, y1, anchor='nw', image=black_checker)
                elif piece == 3:
                    self.canvas.create_image(x1, y1, anchor='nw', image=white_queen)
                elif piece == 4:
                    self.canvas.create_image(x1, y1, anchor='nw', image=black_queen)

    # Метод для обработки щелчка мыши
    def on_click(self, event):
        global take, correct
        correct = False
        col = event.x // 50 # Определение строки и столбца, по которым был произведен щелчок мыши
        row = event.y // 50 # Определение строки и столбца, по которым был произведен щелчок мыши
        # Если шашка не была выбрана
        if self.selected_piece is None: # Получение информации о клетке, по которой был произведен щелчок
            piece = self.board[row][col]
            if piece != 0: # Если на клетке есть шашка
                if piece in self.current_player: # Отображение выбранной клетки на доске
                    self.selected_rectangle = self.canvas.create_rectangle(event.x // 50 * 50, event.y // 50 * 50,
                                                                           event.x // 50 * 50 + 50,
                                                                           event.y // 50 * 50 + 50,
                                                                           outline="red", width=2)
                self.selected_piece = (row, col) # Запоминание выбранной шашки
        else:
            dest_row, dest_col = row, col
            src_row, src_col = self.selected_piece # Проверка, является ли выбранная шашка шашкой текущего игрока
            if self.board[self.selected_piece[0]][
                self.selected_piece[1]] in self.current_player: # Проверка правильности и возможности хода
                correct, take = self.v_moves(src_row, src_col, dest_row, dest_col)
                if correct:
                    # Обработка перемещения шашки и обновление доски
                    if self.board[src_row][src_col] == 1 and dest_row == 0:
                        self.board[dest_row][src_col] = 3
                        self.board[src_row][src_col] = 0
                    elif self.board[src_row][src_col] == 2 and dest_row == 7:
                        self.board[dest_row][src_col] = 4
                        self.board[src_row][src_col] = 0
                    else:
                        self.board[dest_row][dest_col] = self.board[src_row][src_col]
                        self.board[src_row][src_col] = 0
                    if take: # Если было выполнено взятие шашки, обновление игрового поля и отображение выбранной клетки
                        self.selected_piece = dest_row, dest_col
                        self.canvas.delete("all")
                        self.draw_board(self.current_player)
                        self.selected_rectangle = self.canvas.create_rectangle(dest_col * 50, dest_row * 50,
                                                                               dest_col * 50 + 50, dest_row * 50 + 50,
                                                                               outline="blue", width=2)
                    else: # Если взятия не было, переключение текущего игрока и проверка завершения игры
                        self.switch_player()
                        self.selected_piece = None
                        self.canvas.delete("all")
                        self.draw_board(self.current_player)
                        self.need_attack = False
                        self.check_win()
                        self.attack(take, dest_row, dest_col)
                else: # Если ход недопустим, сброс выбранной шашки и обновление игрового поля
                    self.selected_piece = None
                    self.canvas.delete("all")
                    self.draw_board(self.current_player)
            else: # Если выбранная шашка не принадлежит текущему игроку, сброс выбора и обновление поля
                self.selected_piece = None
                self.canvas.delete("all")
                self.draw_board(self.current_player)


# Создание экземпляра класса и запуск программы
if __name__ == "__main__":
    root = Tk()
    app = CheckersBoard(root)
    root.mainloop()


    def switch_player(self):
        # Переключение текущего игрока между [1, 3] и [2, 4]
        if self.current_player == [1, 3]:
            self.current_player = [2, 4]
        else:
            self.current_player = [1, 3]

    def check_win(self):
        # Проверка на завершение игры и определение победителя или ничьей
        count = 0
        count2 = 0
        for i in range(8):
            count += self.board[i].count(1) # Подсчет шашек первого игрока (черные)
            count += self.board[i].count(3) # Подсчет дамок первого игрока (черные)
            count2 += self.board[i].count(2) # Подсчет шашек второго игрока (белые)
            count2 += self.board[i].count(4) # Подсчет дамок второго игрока (белые)
        if count > 0 >= count2: # Проверка на победу одного из игроков или ничью
            messagebox.showinfo("Уведомление", "Победа черных!")
            self.reset_board()
        elif count2 > 0 >= count:
            messagebox.showinfo("Уведомление", "Победа белых!")
            self.reset_board()
        elif count == count2 == 1:
            messagebox.showinfo("Уведомление", "Игра закончилась ничьей!")
            self.reset_board()
        else: # Подсчет возможных ходов для каждого игрока
            count = 0
            count2 = 0
            for i in range(8):
                for j in range(8):
                    if self.board[i][j] in [1, 3]:
                        try:
                            if self.board[i + 1][j] == 0 or (
                                    self.board[i + 1][j] in [2, 4] and self.board[i + 2][j] == 0):
                                count += 1
                            elif self.board[i][j + 1] == 0 or (
                                    self.board[i][j + 1] in [2, 4] and self.board[i][j + 2] == 0):
                                count += 1
                            elif self.board[i][j - 1] == 0 or (
                                    self.board[i][j - 1] in [2, 4] and self.board[i][j - 2] == 0):
                                count += 1
                        except IndexError:
                            pass
                    elif self.board[i][j] in [2, 4]:
                        try:
                            if self.board[i - 1][j] == 0 or (
                                    self.board[i - 1][j] in [1, 3] and self.board[i - 2][j] == 0):
                                count2 += 1
                            elif self.board[i][j + 1] == 0 or (
                                    self.board[i][j + 1] in [1, 3] and self.board[i][j + 2] == 0):
                                count2 += 1
                            elif self.board[i][j - 1] == 0 or (
                                    self.board[i][j - 1] in [1, 3] and self.board[i][j - 2] == 0):
                                count2 += 1
                        except IndexError:
                            pass
            print(count, count2)
            if count == 0: # Проверка, остались ли у игроков ходы
                messagebox.showinfo("Уведомление", "Победа белых!")
                self.reset_board()
            if count2 == 0:
                messagebox.showinfo("Уведомление", "Победа черных!")
                self.reset_board()


    def main():
        # Основная функция запуска игры
        root = Tk() # Создание корневого окна
        app = CheckersBoard(root) # Создание экземпляра игры
        root.mainloop() # Запуск основного цикла программы


    if __name__ == "__main__":
        main()
